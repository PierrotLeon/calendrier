# Running Calendrier as a Standalone App on Your Phone

> **Goal**: run the calendar on an Android or iOS phone **without** keeping a
> server running on a computer in the background.

This document covers **every realistic approach**, from easiest to most
complex.  Each section explains what it is, what file format is produced,
exactly how to do it, and the trade-offs.

---

## Table of Contents

1. [PWA — "Add to Home Screen" (recommended)](#1-pwa--add-to-home-screen)
2. [Self-hosted static files (USB / local storage)](#2-self-hosted-static-files)
3. [TWA — Trusted Web Activity (Android `.apk`)](#3-twa--trusted-web-activity-android-apk)
4. [Capacitor — Native shell (Android `.apk` / iOS `.ipa`)](#4-capacitor--native-shell-android-apk--ios-ipa)
5. [React Native re-write (true native)](#5-react-native-re-write)
6. [Comparison table](#6-comparison-table)

---

## 1. PWA — "Add to Home Screen"

### What it is

A **Progressive Web App** (PWA) is a regular website that a mobile browser
can install as if it were a native app.  It gets its own icon on the home
screen, opens without the browser chrome (address bar, tabs), and works
**fully offline** thanks to a Service Worker that caches all assets.

Calendrier is **already configured as a PWA** (`vite-plugin-pwa` in
`vite.config.js`).  You just need to serve the built files once so your
phone can install them.

### What files are involved

After `npm run build`, the `dist/` folder (~400 KB) contains:

| File | Purpose |
|---|---|
| `index.html` | App entry point |
| `assets/main-*.js` | Bundled React app (single JS file, ~257 KB) |
| `assets/main-*.css` | All styles (~22 KB) |
| `manifest.webmanifest` | PWA metadata (name, icons, theme colour, `display: standalone`) |
| `sw.js` | Service Worker — intercepts fetch requests and serves from cache |
| `workbox-*.js` | Workbox runtime (cache strategies, used by the SW) |
| `registerSW.js` | Tiny script that registers the Service Worker on page load |
| `pwa-192x192.png`, `pwa-512x512.png` | Home-screen and splash-screen icons |
| `apple-touch-icon.png` | iOS-specific home-screen icon |
| `jours_feries_metropole.ics` | French public holidays data file |

The **PWA manifest** (`manifest.webmanifest`) tells the OS:

```json
{
  "name": "Calendrier",
  "short_name": "Calendrier",
  "display": "standalone",
  "start_url": "/",
  "theme_color": "#4F46E5",
  "background_color": "#F8FAFC",
  "icons": [
    { "src": "pwa-192x192.png", "sizes": "192x192", "type": "image/png" },
    { "src": "pwa-512x512.png", "sizes": "512x512", "type": "image/png" }
  ]
}
```

Key fields:
- `"display": "standalone"` → opens without browser UI (no address bar, no tabs)
- `"start_url": "/"` → which page to load when the app is launched
- `"icons"` → home screen icon at various sizes
- `"theme_color"` → status bar colour on Android
- `"background_color"` → splash screen background

The **Service Worker** (`sw.js`) is generated by Workbox during build.  It:
1. Pre-caches every file listed in `globPatterns` (`**/*.{js,css,html,svg,png,ics}`)
2. Intercepts all `fetch()` requests and serves from cache first
3. This is what makes the app work with **zero network** after the first visit

### How to install it — Option A: Free static host (easiest)

You need the `dist/` folder served over **HTTPS** (required for Service
Workers).  Free options:

#### GitHub Pages

```bash
# 1. Create a GitHub repo (e.g., "calendrier")
# 2. Build with the correct base path:
#    In vite.config.js, add:  base: '/calendrier/',
npm run build

# 3. Deploy the dist/ folder
npx gh-pages -d dist
# → Your app is at https://<username>.github.io/calendrier/
```

#### Netlify / Vercel / Cloudflare Pages

```bash
npm run build
# Drag-and-drop the dist/ folder into the Netlify dashboard,
# or connect your Git repo for automatic deploys.
# → You get a free HTTPS URL like https://calendrier.netlify.app
```

Once deployed, open the URL on your phone:

**Android (Chrome):**
1. Open the URL in Chrome.
2. Chrome shows a banner "Add Calendrier to Home screen" — tap it.
   If no banner appears: tap ⋮ (three dots) → **"Install app"** or **"Add to Home screen"**.
3. The app icon appears on your home screen.
4. Opening it launches a standalone window (no browser chrome).
5. After the first load, **it works fully offline** — no server needed.

**iOS (Safari):**
1. Open the URL in **Safari** (not Chrome — iOS only allows Safari to install PWAs).
2. Tap the **Share** button (square with arrow) → **"Add to Home Screen"**.
3. Tap **"Add"**.
4. The app icon appears on your home screen.
5. It works offline after the first load.

### How to install it — Option B: One-time local server

If you don't want to use an online host, you can serve the files from your
computer **once**, install the PWA on the phone, and then shut down the
server.  The Service Worker caches everything — the app will keep working.

```bash
# 1. Build
npm run build

# 2. Serve over your local network
npx serve dist --listen tcp://0.0.0.0:8080
# or:
cd dist && python3 -m http.server 8080 --bind 0.0.0.0

# 3. Find your computer's local IP
hostname -I    # Linux
# → e.g., 192.168.1.145

# 4. On your phone, open: http://192.168.1.145:8080
#    (Note: this is HTTP, not HTTPS.  Service Workers normally require
#     HTTPS, but Chrome makes an exception for private network IPs.
#     On Android this usually works.  On iOS it does NOT —
#     Safari strictly requires HTTPS for Service Workers.)
#
# 5. Install the PWA as described above.
# 6. Close the server on your computer.  The app keeps working.
```

> **iOS caveat**: Safari requires HTTPS for Service Workers, no exceptions.
> For iOS, you need either a real HTTPS host (Option A) or a local HTTPS
> proxy with a self-signed certificate (complicated — Option A is easier).

### How to install it — Option C: Transfer files via USB (Android only)

On Android you can access local files via `file://` URLs, but Service
Workers do **not** work with `file://`.  So this path requires a tiny
on-device HTTP server app:

1. Build: `npm run build`
2. Copy the `dist/` folder to your phone via USB (e.g., to `Internal Storage/calendrier/`).
3. Install a local web server app on your phone:
   - **Simple HTTP Server** (free, Play Store)
   - **Tiny Web Server** (free, Play Store)
4. Point the server app at the `calendrier/` folder, start it on port 8080.
5. Open `http://localhost:8080` in Chrome on the phone.
6. Install the PWA from there.
7. Once installed and cached, you can stop the server app.

This is more work than Option A or B, but requires zero internet.

### Trade-offs

| ✅ Pros | ❌ Cons |
|---|---|
| Already working — zero code changes needed | Needs HTTPS for full PWA on iOS |
| ~400 KB total, loads instantly | No access to phone contacts, calendar API, etc. |
| Full offline support via Service Worker | Updates require re-visiting the URL (auto-update via SW) |
| Same codebase for all platforms | Storage limited to ~5–10 MB in localStorage |
| No app store review process | No push notifications on iOS |

---

## 2. Self-hosted Static Files

### What it is

Serve the `dist/` folder from a **static file server on the phone itself**,
permanently.  This is like Option 1C above but as a permanent setup rather
than a one-time installation trick.

### Why you might want this

- You want to run the app **without** any internet or cloud service, ever.
- You want to keep updating the files on the phone directly.

### How to do it (Android)

1. Install **Termux** (free terminal emulator for Android, available on
   F-Droid — the Play Store version is outdated):
   ```bash
   # In Termux:
   pkg update && pkg install nodejs
   npm install -g serve
   ```

2. Copy the `dist/` folder to Termux's accessible storage:
   ```bash
   termux-setup-storage   # grants access to shared storage
   cp -r /storage/emulated/0/calendrier ~/calendrier
   ```

3. Run the server:
   ```bash
   serve ~/calendrier --listen tcp://127.0.0.1:8080
   ```

4. Open `http://localhost:8080` in Chrome.

5. To make it start automatically, create a Termux boot script:
   ```bash
   mkdir -p ~/.termux/boot
   cat > ~/.termux/boot/calendrier.sh << 'EOF'
   #!/data/data/com.termux/files/usr/bin/sh
   serve ~/calendrier --listen tcp://127.0.0.1:8080 &
   EOF
   chmod +x ~/.termux/boot/calendrier.sh
   ```
   Install the **Termux:Boot** add-on for this to work.

### File format

Same `dist/` folder as the PWA build.  No special packaging.

| Output | Format | Size |
|---|---|---|
| `dist/` folder | Static HTML/JS/CSS/PNG | ~400 KB |

### Trade-offs

| ✅ Pros | ❌ Cons |
|---|---|
| 100 % offline, no internet ever needed | Requires Termux or similar (Android only) |
| Easy to update: just replace the files | Server process runs in background (minimal battery) |
| Full PWA features if accessed via localhost | iOS: no equivalent (no user-accessible terminal) |

---

## 3. TWA — Trusted Web Activity (Android `.apk`)

### What it is

A **Trusted Web Activity** wraps your PWA inside a native Android app
shell.  The result is a real `.apk` file that you can install directly or
publish to the Google Play Store.  Under the hood it opens Chrome (without
the address bar) to render your PWA.

The key difference from a simple PWA shortcut: it's a **real Android app
package** (`.apk`) that appears in Settings → Apps, can be distributed via
`.apk` file transfer or the Play Store, and integrates more deeply with
the OS (app links, Play Store presence).

### File format

| Output | Format | Size |
|---|---|---|
| `app-release.apk` | Android Package (APK) | ~2–5 MB |
| `app-release.aab` | Android App Bundle (for Play Store upload) | ~2–5 MB |

An `.apk` is a ZIP archive containing:

```
app-release.apk
├── AndroidManifest.xml     # App metadata (name, icon, permissions, launch activity)
├── classes.dex             # Compiled Java/Kotlin bytecode (just the TWA launcher)
├── res/                    # Icons and resources
│   ├── mipmap-hdpi/        #   icon at various pixel densities
│   ├── mipmap-xhdpi/
│   ├── mipmap-xxhdpi/
│   └── mipmap-xxxhdpi/
└── META-INF/               # JAR signing certificate
```

### Using PWABuilder (recommended — no local tooling needed)

This is the simplest way to get a `.apk` from a PWA:

1. **Deploy your PWA** to any HTTPS URL (GitHub Pages, Netlify, etc.)
2. Go to **https://www.pwabuilder.com**
3. Enter your PWA URL
4. PWABuilder analyses your manifest, Service Worker, and icons
5. Click **"Package for stores"** → **Android**
6. Configure options (app name, package ID like `com.pierre.calendrier`, signing key)
7. Download the generated `.apk`
8. Transfer the `.apk` to your phone:
   - Email it to yourself
   - Upload to Google Drive, download on phone
   - Transfer via USB
9. Open the `.apk` on your phone → Install
   - Enable **"Install unknown apps"** in Android Settings → Apps → Chrome (or your file manager) if prompted

### Using Bubblewrap CLI (manual, more control)

Bubblewrap is Google Chrome Labs' CLI tool for generating TWA projects.
It requires **Java 17+** and the **Android SDK**.

Visit the official repo to get the current install command:
**https://github.com/nicolo-nicolo/nicolo-nicolo-nicolo**

The general workflow:

```bash
# 1. Make sure your PWA is hosted at an HTTPS URL

# 2. Install Bubblewrap globally (check the repo for the exact package name)
npm install -g <bubblewrap-package>

# 3. Initialize a TWA project from your manifest
bubblewrap init --manifest=https://your-domain.com/manifest.webmanifest
# → Asks questions about app name, package ID, colours, icons
# → Generates an Android project directory

# 4. Build the APK
bubblewrap build
# → Outputs: app-release-signed.apk

# 5. Transfer to phone and install
```

### Signing the APK

For personal side-loading, the debug APK from PWABuilder works without
extra signing.  For Play Store distribution:

```bash
# Generate a signing key (do this once, keep the file safe!)
keytool -genkey -v \
  -keystore calendrier-release.keystore \
  -alias calendrier \
  -keyalg RSA -keysize 2048 \
  -validity 10000
# → Enter a password and your details

# Sign the APK
apksigner sign --ks calendrier-release.keystore app-release.apk

# Verify the signature
apksigner verify app-release.apk
```

### Trade-offs

| ✅ Pros | ❌ Cons |
|---|---|
| Real `.apk` — distributable, installable | Requires Chrome installed on the device |
| Play Store publishable | Needs an HTTPS-hosted PWA (Chrome loads it from the URL) |
| Minimal extra code (just a native launcher) | NOT truly self-contained — depends on network for first load |
| Free with PWABuilder | No iOS equivalent (TWA is Android-only) |

---

## 4. Capacitor — Native Shell (Android `.apk` / iOS `.ipa`)

### What it is

**Capacitor** (by the Ionic team) wraps your web app inside a native
Android/iOS application.  Unlike a TWA, it embeds a **WebView** (a browser
engine built into the app) and bundles your HTML/JS/CSS **inside the
APK/IPA itself**.  No server, no Chrome dependency — everything is
self-contained.

This is the best option if you want a **true standalone app** that:
- Works on both Android and iOS
- Requires no external server, no internet, no browser
- Produces a real `.apk` (Android) or `.ipa` (iOS)
- Can access native device APIs if needed later (notifications, file system, etc.)

### File formats produced

| Output | Format | Platform | Typical size |
|---|---|---|---|
| `app-debug.apk` | Android Package | Android | ~5–10 MB |
| `app-release.aab` | Android App Bundle (Play Store) | Android | ~3–8 MB |
| `App.ipa` | iOS App Archive | iOS | ~5–10 MB |

### What's inside the APK

```
app-debug.apk  (it's a ZIP file)
├── AndroidManifest.xml              # App metadata, permissions
├── classes.dex                      # Compiled Kotlin/Java (WebView launcher)
├── res/                             # Icons, layouts, strings
│   ├── mipmap-xxxhdpi/icon.png
│   └── ...
├── assets/
│   └── public/                      # ← Your dist/ folder lives here!
│       ├── index.html
│       ├── assets/main-*.js         # Your bundled React app
│       ├── assets/main-*.css        # Your styles
│       ├── manifest.webmanifest
│       ├── pwa-192x192.png
│       ├── jours_feries_metropole.ics
│       └── ...
├── lib/                             # Native libraries (Capacitor bridge)
│   ├── arm64-v8a/
│   └── armeabi-v7a/
└── META-INF/                        # Signing info
```

### What's inside the IPA (iOS)

```
App.ipa  (also a ZIP file)
└── Payload/
    └── App.app/                     # The app bundle
        ├── Info.plist               # App metadata (name, version, permissions)
        ├── public/                  # ← Your dist/ folder
        │   ├── index.html
        │   ├── assets/main-*.js
        │   └── ...
        ├── capacitor.config.json    # Capacitor settings
        └── Frameworks/              # Native frameworks (WebView bridge)
```

### Prerequisites

**For Android:**
- **Android Studio** (free, ~1 GB download) — https://developer.android.com/studio
- **Java 17+** (usually bundled with Android Studio)

**For iOS:**
- **macOS** (required — Apple does not allow iOS builds on Linux/Windows)
- **Xcode** (free from the Mac App Store, ~12 GB)
- **Apple Developer account** (free for on-device testing, €99/year for App Store)

### Step-by-step

```bash
# ──────────────────────────────────────────────────
# STEP 1: Build the web app
# ──────────────────────────────────────────────────
cd /home/pierre/Documents/experiments/calendrier/app_calendrier
npm run build
# → produces dist/ folder

# ──────────────────────────────────────────────────
# STEP 2: Install Capacitor
# ──────────────────────────────────────────────────
# Capacitor has two packages: a core runtime and a CLI tool.
# Visit https://capacitorjs.com/docs/getting-started for the
# latest install command.  As of 2026 it is:
npm install @capacitor/core
npm install -D @capacitor/cli

# ──────────────────────────────────────────────────
# STEP 3: Initialize Capacitor in the project
# ──────────────────────────────────────────────────
npx cap init "Calendrier" "com.pierre.calendrier" --web-dir=dist

# This creates capacitor.config.ts in the project root:
# {
#   "appId": "com.pierre.calendrier",
#   "appName": "Calendrier",
#   "webDir": "dist"
# }

# ──────────────────────────────────────────────────
# STEP 4: Add the Android platform
# ──────────────────────────────────────────────────
npm install @capacitor/android
npx cap add android
# → Creates an android/ folder containing a full Gradle project

# ──────────────────────────────────────────────────
# STEP 5: Copy your built web files into the native project
# ──────────────────────────────────────────────────
npx cap copy android
# → Copies everything from dist/ into android/app/src/main/assets/public/

# ──────────────────────────────────────────────────
# STEP 6: Open in Android Studio
# ──────────────────────────────────────────────────
npx cap open android
# → Opens the android/ project in Android Studio

# ──────────────────────────────────────────────────
# STEP 7: Build & run from Android Studio
# ──────────────────────────────────────────────────
# In Android Studio:
#   1. Wait for Gradle sync to complete (first time takes a few minutes)
#   2. Connect your phone via USB (enable USB debugging in Developer Options)
#   3. Click the green ▶ "Run" button
#   4. Select your connected phone
#   5. The APK is built and installed automatically
#
# To generate a standalone APK file:
#   Build → Build Bundle(s) / APK(s) → Build APK(s)
#   Output: android/app/build/outputs/apk/debug/app-debug.apk

# ──────────────────────────────────────────────────
# STEP 8: Transfer the APK (if not using USB debug)
# ──────────────────────────────────────────────────
# Option A: ADB (if phone is connected via USB)
adb install android/app/build/outputs/apk/debug/app-debug.apk

# Option B: Copy the .apk file to your phone via USB file transfer,
#           email, or cloud storage.  Open it on the phone to install.
#           Enable "Install unknown apps" in Android Settings if prompted.
```

### Capacitor configuration file

After `npx cap init`, you get `capacitor.config.ts` in the project root:

```typescript
import type { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  appId: 'com.pierre.calendrier',
  appName: 'Calendrier',
  webDir: 'dist',
  server: {
    // Load from bundled files, not a remote URL
    androidScheme: 'https',  // makes localStorage behave correctly in WebView
  },
};

export default config;
```

### For iOS (requires a Mac)

```bash
# After steps 1–3 above, then:
npm install @capacitor/ios
npx cap add ios
npx cap copy ios
npx cap open ios
# → Opens the ios/ folder as an Xcode project

# In Xcode:
#   1. Select your iPhone as the target device
#   2. Go to Signing & Capabilities → set your Team
#      (a free Apple ID works for personal/development testing)
#   3. Click ▶ to build and run on your device
```

### What about the Service Worker?

Inside a Capacitor app, the Service Worker is **optional**.  The files are
already bundled inside the APK/IPA and loaded from the local filesystem.
The Service Worker won't cause problems if left in, but it's not needed for
offline functionality — the app **is** the offline version.

### Updating the app after code changes

```bash
npm run build            # rebuild the web app
npx cap copy android     # copy new dist/ into the Android project
npx cap open android     # open in Android Studio → Run
```

### Trade-offs

| ✅ Pros | ❌ Cons |
|---|---|
| True standalone app — no server, no browser needed | Requires Android Studio (~1 GB) |
| Works on both Android and iOS | iOS requires macOS + Xcode |
| Real `.apk` / `.ipa` files | Slightly larger than PWA (~5–10 MB vs ~400 KB) |
| Can add native plugins later (camera, notifications, etc.) | Extra build step for each update |
| Uses the exact same web codebase — zero rewrite | WebView performance slightly below native (unnoticeable for a calendar) |
| Full localStorage support | |
| No internet required, ever | |

---

## 5. React Native Re-write

### What it is

A complete rewrite of the app using **React Native** instead of React DOM.
The UI components would be truly native (Android Views / iOS UIKit), not a
WebView rendering HTML.

### Why you probably don't want this

- Calendrier is ~4,000 lines of React + CSS.  A React Native rewrite would
  be a **near-total rewrite** — all components, all styles, most hooks.
- React Native doesn't use CSS — it uses `StyleSheet.create()` with a
  subset of CSS properties (no CSS grid, no `::before`/`::after`, no
  CSS custom properties, limited flexbox).
- `localStorage` doesn't exist — you'd use `AsyncStorage` or
  `react-native-mmkv`.
- `date-fns` works fine, but everything UI-related changes.
- Estimated effort: **2–4 weeks** for a developer familiar with RN.

### When it would make sense

- If you wanted to distribute on the App Store / Play Store commercially.
- If you needed deep native integrations (syncing with the phone's built-in
  calendar, push notifications, home-screen widgets).
- If performance were a concern (it isn't for a calendar app).

### File format

| Output | Format | Platform | Typical size |
|---|---|---|---|
| `app-release.apk` | Android Package | Android | ~10–20 MB |
| `App.ipa` | iOS App Archive | iOS | ~10–20 MB |

### Trade-offs

| ✅ Pros | ❌ Cons |
|---|---|
| Best native performance and feel | Near-total rewrite (~2–4 weeks of work) |
| Deep OS integration | Two codebases to maintain |
| Smallest possible battery usage | ~50× larger than the PWA |
| App Store distribution | Need to learn React Native if unfamiliar |

---

## 6. Comparison Table

| Approach | Effort | Output | Size | Offline | Android | iOS | Server needed |
|---|---|---|---|---|---|---|---|
| **PWA (hosted)** | Zero (already done) | — (browser install) | ~400 KB | ✅ (SW cache) | ✅ | ✅ (HTTPS only) | First install only |
| **PWA (local one-time serve)** | 5 min | — | ~400 KB | ✅ | ✅ | ❌ | One-time only |
| **Static on phone (Termux)** | 15 min | `dist/` folder | ~400 KB | ✅ | ✅ | ❌ | On-device |
| **TWA via PWABuilder** | 30 min | `.apk` (2–5 MB) | ~3 MB | Partial | ✅ | ❌ | Hosted PWA |
| **Capacitor** | 1–2 hours | `.apk` / `.ipa` | ~7 MB | ✅ (self-contained) | ✅ | ✅ (Mac needed) | ❌ Never |
| **React Native** | 2–4 weeks | `.apk` / `.ipa` | ~15 MB | ✅ | ✅ | ✅ (Mac needed) | ❌ Never |

---

## Recommendation

### 5 minutes → **PWA on GitHub Pages / Netlify** (Section 1A)

Deploy to a free HTTPS host, install on your phone.  Done.  Works offline.
Zero code changes needed.  This is what I'd do first.

### Want a real `.apk` file → **Capacitor** (Section 4)

One-time setup of Android Studio, then a repeatable
`npm run build && npx cap copy android` workflow.  Produces a real app —
no server, no browser dependency, everything bundled in the APK.

### Never want any internet, ever → **Capacitor** or **Termux**

Capacitor bundles everything in the APK.  Termux serves files locally.
Both work in airplane mode forever.

---

## Appendix: Quick-Deploy to GitHub Pages

Since the PWA approach requires zero code changes, here are the exact
commands:

```bash
# 1. Set the base path for GitHub Pages
#    In vite.config.js, add to defineConfig:  base: '/calendrier/',
#    (where "calendrier" matches your GitHub repo name)

# 2. Build
cd /home/pierre/Documents/experiments/calendrier/app_calendrier
npm run build

# 3. Install gh-pages helper
npm install -D gh-pages

# 4. Add a deploy script to package.json:
#    "scripts": { ..., "deploy": "gh-pages -d dist" }

# 5. Initialize git and push to GitHub (if not already done)
git init
git remote add origin https://github.com/<your-username>/calendrier.git
git add -A && git commit -m "initial commit"
git push -u origin main

# 6. Deploy
npm run deploy
# → Pushes dist/ contents to the gh-pages branch

# 7. In the GitHub repo: Settings → Pages → Source: "Deploy from branch: gh-pages"

# 8. Wait ~1 minute, then visit:
#    https://<your-username>.github.io/calendrier/

# 9. On your phone, open that URL in Chrome (Android) or Safari (iOS)
#    → "Add to Home Screen" / "Install app"

# 10. Done!  The app icon is on your home screen and works offline.
```
